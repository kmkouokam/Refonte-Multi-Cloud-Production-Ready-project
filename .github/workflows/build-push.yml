name: Build and Push Flask App Image  #

on:
  push:
    branches: ["flask-app"]

permissions:
  contents: write
  id-token: write

env:
  IMAGE_NAME: flask-app

jobs:
  # ----------------------------------------
  # 1Ô∏è‚É£ AWS JOB
  # ----------------------------------------
  aws-build-push:
    runs-on: [self-hosted, linux, vpc-runner]
    environment: production

    env:
      AWS_REGION: ${{ secrets.AWS_REGION }}
      AWS_ACCOUNT_ID: ${{ secrets.AWS_ACCOUNT_ID }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      # Configure AWS
      # - name: Configure AWS Credentials
      #   uses: aws-actions/configure-aws-credentials@v2
      #   with:
      #     role-to-assume: arn:aws:iam::${{ env.AWS_ACCOUNT_ID }}:role/GitHubActionsRole
      #     aws-region: ${{ env.AWS_REGION }}

      - name: Check AWS Identity (Self-Hosted Runner)
        run: aws sts get-caller-identity


      - name: Login to AWS ECR
        run: |
          aws ecr get-login-password --region $AWS_REGION |
          docker login --username AWS --password-stdin \
          $AWS_ACCOUNT_ID.dkr.ecr.$AWS_REGION.amazonaws.com

      # Build Docker Image
      - name: Build Image
        run: |
          docker build -t $IMAGE_NAME -f flask_app/Dockerfile .
          docker tag $IMAGE_NAME:latest \
            $AWS_ACCOUNT_ID.dkr.ecr.$AWS_REGION.amazonaws.com/$IMAGE_NAME:${GITHUB_SHA}

      - name: Push Image to AWS ECR
        run: |
          docker push \
            $AWS_ACCOUNT_ID.dkr.ecr.$AWS_REGION.amazonaws.com/$IMAGE_NAME:${GITHUB_SHA}

      # Configure EKS
      - name: Update kubeconfig for AWS EKS
        env:
          AWS_REGION: ${{ env.AWS_REGION }}
          CLUSTER_NAME: multi-cloud-cluster
        run: |
          aws eks update-kubeconfig \
            --name multi-cloud-cluster \
            --region $AWS_REGION

      - name: Install ArgoCD on AWS
        run: |
          kubectl create namespace argocd || true
          kubectl apply -n argocd \
            -f https://raw.githubusercontent.com/argoproj/argo-cd/stable/manifests/install.yaml
          kubectl apply \
            -f https://raw.githubusercontent.com/argoproj/argo-rollouts/stable/manifests/install.yaml
          kubectl wait --for=condition=ready pod -n argocd --all --timeout=180s

      # Update gitop branch
      - name: Update AWS rollout manifests
        run: |
          git config --global user.name "GitHub Actions"
          git config --global user.email "actions@github.com"

          git clone --branch gitop \
            https://x-access-token:${{ secrets.GITHUB_TOKEN }}@github.com/${{ github.repository }} gitop

          cd gitop/argocd
           
          # Update AWS Rollout image
          sed -i "s|\${GITHUB_SHA}|$GITHUB_SHA|" flask-app-aws-rollout.yaml

           # Commit & push changes
          if ! git diff --quiet; then  
            git add flask-app-aws-rollout.yaml
            git commit -m "Update AWS rollout image $GITHUB_SHA"
            git push origin gitop
          else
            echo "No changes to commit"
          fi

      - name: deploy ingress-aws and secret-aws
        run: |
          cd gitop/argocd/k8s
          kubectl apply -f ingress-aws.yaml 
          kubectl apply -f secret-aws.yaml   

        # ----------------------------------------
      #
      # üö® SLACK NOTIFICATION FOR AWS JOB
      # ----------------------------------------
      - name: Slack Notify AWS Job
        if: always()
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
        run: |
          STATUS="${{ job.status }}"
          COMMIT=$GITHUB_SHA
          REPO=$GITHUB_REPOSITORY
          JOB="AWS Build & Deploy"

          curl -X POST -H 'Content-type: application/json' \
            --data "{
              \"text\": \"*$JOB* finished with status: *$STATUS*\nRepo: $REPO\nCommit: $COMMIT\"
            }" \
            $SLACK_WEBHOOK_URL
    
#
  # ----------------------------------------
  # 2Ô∏è‚É£ GCP JOB
  # ----------------------------------------
  gcp-build-push:
    runs-on: [self-hosted, linux, vpc-runner]
    # needs: aws-build-push   # wait for AWS job to finish before starting GCP job

    env:
      GCP_PROJECT_ID: ${{ secrets.GCP_PROJECT_ID }}
      GCP_PROJECT_NUMBER: ${{ secrets.GCP_PROJECT_NUMBER }}
      IMAGE_NAME: flask-app
      GCP_REGION: ${{ secrets.GCP_REGION }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      # Authenticate to GCP
      - name: Authenticate to GCP
        uses: google-github-actions/auth@v3
        with:
          project_id: ${{ env.GCP_PROJECT_ID }}
          workload_identity_provider: ${{ secrets.WORKLOAD_IDENTITY_PROVIDER }}
          service_account: "refonte-project@prod-251618-359501.iam.gserviceaccount.com"

      - name: Setup gcloud cloud SDK
        uses: google-github-actions/setup-gcloud@v3
        with:
          project_id: ${{ env.GCP_PROJECT_ID }}
          service_account_key: ${{ secrets.GCP_SA_KEY }}
          export_default_credentials: true

      - name: Get GKE credentials
        uses: google-github-actions/get-gke-credentials@v3
        with:
          cluster_name:  my-gcp-cluster-f6491c365590
          location: ${{ env.GCP_REGION }}
          project_id: ${{ env.GCP_PROJECT_ID }}

      - name: Install gke auth plugin
        run: |
         # Detect package manager
          if command -v apt-get >/dev/null 2>&1; then
            sudo apt-get update -y
            sudo apt-get install -y apt-transport-https ca-certificates gnupg curl
          elif command -v yum >/dev/null 2>&1; then
            sudo yum update -y
            sudo yum install -y curl ca-certificates
          else
            echo "No supported package manager found"
            exit 1
          fi

         # If using apt-get, add Google Cloud SDK repo
          if command -v apt-get >/dev/null 2>&1; then
            curl -fsSL https://packages.cloud.google.com/apt/doc/apt-key.gpg | sudo gpg --dearmor -o /usr/share/keyrings/cloud.google.gpg
            echo "deb [signed-by=/usr/share/keyrings/cloud.google.gpg] https://packages.cloud.google.com/apt cloud-sdk main" | \
            sudo tee /etc/apt/sources.list.d/google-cloud-sdk.list
            sudo apt-get update
            sudo apt-get install -y google-cloud-sdk
          else
         # For yum/dnf based distros, install Google Cloud SDK via yum
           sudo tee /etc/yum.repos.d/google-cloud-sdk.repo > /dev/null <<EOM
         [google-cloud-sdk]
         name=Google Cloud SDK
         baseurl=https://packages.cloud.google.com/yum/repos/cloud-sdk-el7-x86_64
         enabled=1
         gpgcheck=1
         repo_gpgcheck=1
         gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-google-cloud
         EOM

         # Import Google Cloud GPG keys
         sudo rpm --import https://packages.cloud.google.com/yum/doc/yum-key.gpg
         sudo rpm --import https://packages.cloud.google.com/yum/doc/rpm-package-key.gpg

         sudo yum clean packages
         sudo yum install -y google-cloud-sdk
          fi

         # Install the gke-gcloud-auth-plugin
          gcloud components install gke-gcloud-auth-plugin --quiet

         # Authenticate to GCP
          echo "${{ secrets.GCP_SA_KEY }}" | base64 --decode > gcp-key.json
          gcloud auth activate-service-account --key-file=gcp-key.json --quiet
    
      # - name: Install gke auth plugin
      #   run: |
      #     sudo apt-get update -y || sudo yum update -y
      #     sudo apt-get install apt-transport-https ca-certificates gnupg curl -y

      #     # Add Google Cloud SDK repository
      #     curl -fsSL https://packages.cloud.google.com/apt/doc/apt-key.gpg | sudo gpg --dearmor -o /usr/share/keyrings/cloud.google.gpg

      #     echo "deb [signed-by=/usr/share/keyrings/cloud.google.gpg] https://packages.cloud.google.com/apt cloud-sdk main" | \
      #     sudo tee /etc/apt/sources.list.d/google-cloud-sdk.list

      #     sudo apt-get update
      #     sudo apt-get install -y google-cloud-sdk

      #     # Install the gke-gcloud-auth-plugin
      #     gcloud components install gke-gcloud-auth-plugin --quiet

      #      # Authenticate to GCP
      #        echo "${{ secrets.GCP_SA_KEY }}" | base64 --decode > gcp-key.json
      #      gcloud auth activate-service-account --key-file=gcp-key.json --quiet

        #  Clean and reconfigure Docker auth for Artifact Registry
      - name: Clean old Docker logins (optional safeguard)
        run: |
          docker logout https://${{ env.GCP_REGION }}-docker.pkg.dev || true

      - name: Ensure Artifact Registry repo exists
        run: |
         if ! gcloud artifacts repositories describe my-repo --location=${{ env.GCP_REGION }} >/dev/null 2>&1; then
         gcloud artifacts repositories create my-repo \
         --repository-format=docker \
         --location=${{ env.GCP_REGION }} \
         --description="Docker repo for my project"
         echo "Waiting for repo to be ready..."
         sleep 15
         fi
    

      - name: Docker login to GCP Artifact Registry
        run: |
          docker logout https://${{ env.GCP_REGION }}-docker.pkg.dev || true
          gcloud auth configure-docker ${{ env.GCP_REGION }}-docker.pkg.dev --quiet

        # ‚úÖ (Optional fallback: Manual login if gcloud helper fails)
      - name: Fallback Docker login (only if needed)
        if: failure()
        run: |
          gcloud auth print-access-token | \
          docker login -u oauth2accesstoken --password-stdin https://${{ env.GCP_REGION }}-docker.pkg.dev

      # Build Docker Image
      - name: Build GCP Image
        run: |
          docker build -t $IMAGE_NAME -f flask_app/Dockerfile .
          docker tag $IMAGE_NAME:latest \
            ${{ env.GCP_REGION }}-docker.pkg.dev/$GCP_PROJECT_ID/my-repo/$IMAGE_NAME:${GITHUB_SHA}

      - name: Login to Artifact Registry
        run: |
          gcloud auth configure-docker ${{ env.GCP_REGION }}-docker.pkg.dev --quiet

      - name: Push to GCP Artifact Registry
        run: |
          docker push \
            ${{ env.GCP_REGION }}-docker.pkg.dev/$GCP_PROJECT_ID/my-repo/$IMAGE_NAME:${GITHUB_SHA}

      # Install ArgoCD on GCP
      - name: Install ArgoCD on GKE
        run: |
          kubectl create namespace argocd || true
          kubectl apply -n argocd \
            -f https://raw.githubusercontent.com/argoproj/argo-cd/stable/manifests/install.yaml
          kubectl apply \
            -f https://raw.githubusercontent.com/argoproj/argo-rollouts/stable/manifests/install.yaml
          kubectl wait --for=condition=ready pod -n argocd --all --timeout=180s

      # Update gitop branch
      - name: Update GCP rollout manifests
        run: |
          git config --global user.name "GitHub Actions"
          git config --global user.email "actions@github.com"

          git clone --branch gitop \
            https://x-access-token:${{ secrets.GITHUB_TOKEN }}@github.com/${{ github.repository }} gitop

          cd gitop/argocd

          # Update GCP Rollout image
          sed -i "s|\${GITHUB_SHA}|$GITHUB_SHA|" flask-app-gcp-rollout.yaml
          sed -i "s|\${GCP_PROJECT_ID}|$GCP_PROJECT_ID|" flask-app-gcp-rollout.yaml

          git add flask-app-gcp-rollout.yaml
          git commit -m "Update GCP rollout image $GITHUB_SHA" || true
          git push origin gitop || true


      - name: deploy ingress-gcp and secret-gcp
        run: |
          cd gitop/argocd/k8s
          kubectl apply -f ingress-gcp.yaml 
          kubectl apply -f secret-gcp.yaml   

        # ----------------------------------------
      # üö® SLACK NOTIFICATION FOR GCP JOB
      # ----------------------------------------
      - name: Slack Notify GCP Job
        if: always()
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
        run: |
          STATUS="${{ job.status }}"
          COMMIT=$GITHUB_SHA
          REPO=$GITHUB_REPOSITORY
          JOB="GCP Build & Deploy"

          curl -X POST -H 'Content-type: application/json' \
            --data "{
              \"text\": \"*$JOB* finished with status: *$STATUS*\nRepo: $REPO\nCommit: $COMMIT\"
            }" \
            $SLACK_WEBHOOK_URL

#############################################################################################

# Below steps to use if you do not want to use ArgoCD for deployment
#############################################################################################

##### if step 8 is used, skeep step 9 and vice versa #####
# 8Ô∏è‚É£ Deploy to GKE
# - name: Deploy to GKE
#   run: |
#     git fetch origin gitop
#     git checkout gitop
#     kubectl apply -f k8s/flask-app/deployment-gcp.yaml
# kubectl apply -f k8s/service.yaml
# kubectl apply -f k8s/ingress-gcp.yaml
# kubectl apply -f k8s/secret-gcp.yaml

# # Deploy to AWS Eks
# - name: Deploy to AWS EKS
#   env:
#     AWS_REGION: ${{ env.AWS_REGION }}
#     CLUSTER_NAME:  multi-cloud-cluster # replace with your EKS cluster name
#   run: |
#     # Update kubeconfig for EKS
#      git fetch origin gitop
#      git checkout gitop
#      aws eks update-kubeconfig --name $CLUSTER_NAME --region $AWS_REGION
#      kubectl apply -f k8s/flask-app/deployment-aws.yaml
# kubectl apply -f k8s/service.yaml
# kubectl apply -f k8s/ingress-aws.yaml
# kubectl apply -f k8s/secret-aws.yaml

##### end of alternative steps #####

