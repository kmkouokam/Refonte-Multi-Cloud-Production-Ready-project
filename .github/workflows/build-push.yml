name: Build and Push Flask App Image  #

on:
  push:
    branches: ["flask-app"]

permissions:
  contents: write
  id-token: write

env:
  IMAGE_NAME: flask-app
  ARGOCD_USERNAME: admin
  ARGOCD_PASSWORD: ${{ secrets.ARGOCD_PASSWORD }}

jobs:
  # ----------------------------------------
  # 1ï¸âƒ£ AWS JOB
  # ----------------------------------------
  aws-build-push:
    runs-on: [self-hosted, linux, vpc-runner]
    environment: production

    env:
      AWS_REGION: ${{ secrets.AWS_REGION }}
      AWS_ACCOUNT_ID: ${{ secrets.AWS_ACCOUNT_ID }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

            

      - name: Check AWS Identity (Self-Hosted Runner)
        run: aws sts get-caller-identity


      - name: Login to AWS ECR
        run: |
          aws ecr get-login-password --region $AWS_REGION |
          docker login --username AWS --password-stdin \
          $AWS_ACCOUNT_ID.dkr.ecr.$AWS_REGION.amazonaws.com

      # Build Docker Image
      - name: Build Image
        run: |
          docker build -t $IMAGE_NAME -f flask_app/Dockerfile .
          docker tag $IMAGE_NAME:latest \
            $AWS_ACCOUNT_ID.dkr.ecr.$AWS_REGION.amazonaws.com/$IMAGE_NAME:${GITHUB_SHA}

      - name: Push Image to AWS ECR
        run: |
          docker push \
            $AWS_ACCOUNT_ID.dkr.ecr.$AWS_REGION.amazonaws.com/$IMAGE_NAME:${GITHUB_SHA}

      - name: Create ECR Pull Secret
        run: |
         kubectl create secret docker-registry ecr-creds \
         --docker-server=$AWS_ACCOUNT_ID.dkr.ecr.$AWS_REGION.amazonaws.com \
         --docker-username=AWS \
         --docker-password=$(aws ecr get-login-password --region $AWS_REGION) \
         -n default || true


      # Configure EKS
      - name: Update kubeconfig for AWS EKS
        env:
          AWS_REGION: ${{ env.AWS_REGION }}
          CLUSTER_NAME: multi-cloud-cluster
        run: |
          aws eks update-kubeconfig \
            --name multi-cloud-cluster \
            --region $AWS_REGION

      - name: Install ArgoCD on AWS
        run: |
          kubectl create namespace argocd || true
          kubectl apply -n argocd \
            -f https://raw.githubusercontent.com/argoproj/argo-cd/stable/manifests/install.yaml
          kubectl apply \
            -f https://raw.githubusercontent.com/argoproj/argo-rollouts/stable/manifests/install.yaml
          kubectl wait --for=condition=ready pod -n argocd --selector=app.kubernetes.io/name=argocd-server --timeout=300s

          # Wait additionally until the argocd-cm exists
          until kubectl get configmap argocd-cm -n argocd >/dev/null 2>&1; do
            echo "Waiting for argocd-cm to be created..."
            sleep 5
          done


      - name: Expose ArgoCD server externally
        run: |
          kubectl -n argocd patch svc argocd-server -p '{"spec": {"type": "LoadBalancer"}}'
          # Wait until an external IP/DNS is assigned
           ARGOCD_SERVER_EXTERNAL=""
          while [ -z "$ARGOCD_SERVER_EXTERNAL" ]; do
          echo "Waiting for ArgoCD LoadBalancer IP..."
           ARGOCD_SERVER_EXTERNAL=$(kubectl -n argocd get svc argocd-server -o jsonpath='{.status.loadBalancer.ingress[0].hostname}')
           sleep 5
           done
           echo "ArgoCD external endpoint: $ARGOCD_SERVER_EXTERNAL"
          echo "ARGOCD_SERVER_EXTERNAL=$ARGOCD_SERVER_EXTERNAL" >> $GITHUB_ENV


      - name: Get ArgoCD External Endpoint
        id: argocd-endpoint
        run: |
         EXTERNAL=$(kubectl -n argocd get svc argocd-server -o jsonpath='{.status.loadBalancer.ingress[0].hostname}')
         echo "external=$EXTERNAL" >> $GITHUB_OUTPUT


   

      # Update gitop branch
      - name: Update AWS rollout manifests
        run: |
          git config --global user.name "GitHub Actions"
          git config --global user.email "actions@github.com"

          git clone --branch gitop \
            https://x-access-token:${{ secrets.GITHUB_TOKEN }}@github.com/${{ github.repository }} gitop

          cd gitop/argocd
           
          # Update AWS Rollout image
          sed -i "s|\${GITHUB_SHA}|$GITHUB_SHA|" flask-app-aws-rollout.yaml

           # Commit & push changes
          if ! git diff --quiet; then  
            git add flask-app-aws-rollout.yaml
            git commit -m "Update AWS rollout image $GITHUB_SHA"
            git push origin gitop
          else
            echo "No changes to commit"
          fi

      - name: Fetch DB credentials from terraform outputs
        run: |
          # chackout master to fetch latest terraform outputs
          git fetch origin master
          git checkout master 
          # AWS DB credentials
          export AWS_DB_USERNAME=$(terraform output -raw aws_db_username)
          export AWS_DB_PASSWORD=$(terraform output -raw aws_db_password)
          export AWS_DB_HOST=$(terraform output -raw aws_db_host)
          export AWS_DB_NAME=$(terraform output -raw aws_db_name)

          # Persist to GitHub Actions environment
          echo "AWS_DB_USERNAME=$AWS_DB_USERNAME" >> $GITHUB_ENV
          echo "AWS_DB_PASSWORD=$AWS_DB_PASSWORD" >> $GITHUB_ENV
          echo "AWS_DB_HOST=$AWS_DB_HOST" >> $GITHUB_ENV
          echo "AWS_DB_NAME=$AWS_DB_NAME" >> $GITHUB_ENV

      - name: Apply Kubernetes Secret
        run: |
           cd gitop/argocd/k8s
           envsubst < secret-aws.yaml | kubectl apply -f -


      - name: deploy ingress-aws and service-aws
        run: |
          cd gitop/argocd/k8s
          kubectl apply -f ingress-aws.yaml 
          kubectl apply -f service-aws.yaml   

       

      
       

      - name: Create or Upsert ArgoCD App (AWS)
        run: |
         argocd app create flask-app-aws \
          --repo https://github.com/kmkouokam/Refonte-Multi-Cloud-Production-Ready-project.git \
          --path argocd \
          --revision gitop \
          --dest-server https://kubernetes.default.svc \
          --dest-namespace default \
          --server https://${{ steps.argocd-endpoint.outputs.external }} \
          --grpc-web=false \
          --upsert \
          --core

      - name: Sync AWS App
        run: |
          argocd app sync flask-app-aws \
          --grpc-web=false \
          --server https://${{ steps.argocd-endpoint.outputs.external }} \
           --timeout 300
           
           
#

      - name: Update ArgoCD App Image (AWS)
        run: |
         echo "Updating ArgoCD deployment image to $IMAGE_URI ..."
         argocd app set flask-app-aws \
         --image $IMAGE_URI \
         --grpc-web=false \
         --server https://${{ steps.argocd-endpoint.outputs.external }} \
         --timeout 60

         argocd app sync flask-app-aws \
           --grpc-web=false \
           --timeout 60
           --server https://${{ steps.argocd-endpoint.outputs.external }}
   

        # ----------------------------------------
      #
      # ðŸš¨ SLACK NOTIFICATION FOR AWS JOB
      # ----------------------------------------
      - name: Slack Notify AWS Job
        if: always()
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
        run: |
          STATUS="${{ job.status }}"
          COMMIT=$GITHUB_SHA
          REPO=$GITHUB_REPOSITORY
          JOB="AWS Build & Deploy"

          curl -X POST -H 'Content-type: application/json' \
            --data "{
              \"text\": \"*$JOB* finished with status: *$STATUS*\nRepo: $REPO\nCommit: $COMMIT\"
            }" \
            $SLACK_WEBHOOK_URL
    
#
  # ----------------------------------------
  # 2ï¸âƒ£ GCP JOB
  # ----------------------------------------
  gcp-build-push:
    runs-on: [self-hosted, linux, vpc-runner]
    # needs: aws-build-push   # wait for AWS job to finish before starting GCP job

    env:
     GCP_PROJECT_ID: ${{ secrets.GCP_PROJECT_ID }}
     GCP_PROJECT_NUMBER: ${{ secrets.GCP_PROJECT_NUMBER }}
     IMAGE_NAME: flask-app
     GCP_REGION: ${{ secrets.GCP_REGION }}
     GCP_CLUSTER_NAME: my-gcp-cluster-1c11e8a96f4d


    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      # Authenticate to GCP
      - name: Authenticate to GCP
        uses: google-github-actions/auth@v3
        with:
          project_id: ${{ env.GCP_PROJECT_ID }}
          workload_identity_provider: ${{ secrets.WORKLOAD_IDENTITY_PROVIDER }}
          service_account: "refonte-project@prod-251618-359501.iam.gserviceaccount.com"

      - name: Setup gcloud cloud SDK
        uses: google-github-actions/setup-gcloud@v3
        with:
          project_id: ${{ env.GCP_PROJECT_ID }}
          service_account_key: ${{ secrets.GCP_SA_KEY }}
          export_default_credentials: true

      - name: Get GKE credentials
        uses: google-github-actions/get-gke-credentials@v3
        with:
          cluster_name:  ${{ env.GCP_CLUSTER_NAME }}
          location: ${{ env.GCP_REGION }}
          project_id: ${{ env.GCP_PROJECT_ID }}

      - name: Install Google Cloud SDK
        run: |
         # Create safe directory
         mkdir -p /home/ec2-user/gcloud
         cd /home/ec2-user/gcloud 
         # Detect package manager
         if command -v apt-get >/dev/null 2>&1; then
          sudo apt-get update -y
          sudo apt-get install -y apt-transport-https ca-certificates gnupg curl
         elif command -v yum >/dev/null 2>&1 || command -v dnf >/dev/null 2>&1; then
          sudo yum update -y || sudo dnf update -y
          sudo yum install -y curl ca-certificates || sudo dnf install -y curl ca-certificates
         else
           echo "No supported package manager found"
          exit 1
         fi

          # If using apt-get, install Google Cloud SDK via apt repo
         if command -v apt-get >/dev/null 2>&1; then
           curl -fsSL https://packages.cloud.google.com/apt/doc/apt-key.gpg | sudo gpg --dearmor -o /usr/share/keyrings/cloud.google.gpg
           echo "deb [signed-by=/usr/share/keyrings/cloud.google.gpg] https://packages.cloud.google.com/apt cloud-sdk main" | \
           sudo tee /etc/apt/sources.list.d/google-cloud-sdk.list
           sudo apt-get update
           sudo apt-get install -y google-cloud-sdk
         else
         # For Amazon Linux 2023 or other yum/dnf distros, use Google's install script
           curl -O https://dl.google.com/dl/cloudsdk/channels/rapid/downloads/google-cloud-cli-linux-x86_64.tar.gz
           tar -xf google-cloud-cli-linux-x86_64.tar.gz
           sudo ./google-cloud-sdk/install.sh --quiet
           echo "export PATH=$PATH:/root/google-cloud-sdk/bin" >> ~/.bashrc
           source ~/.bashrc
          fi

      - name: Install GKE auth plugin and authenticate to GCP
        run: |
         # Install gke plugin
          gcloud components install gke-gcloud-auth-plugin --quiet

          # Authenticate to GCP
           echo "${{ secrets.GCP_SA_KEY }}" | base64 --decode > gcp-key.json
           gcloud auth activate-service-account --key-file=gcp-key.json --quiet
  

       

        #  Clean and reconfigure Docker auth for Artifact Registry
      - name: Clean old Docker logins (optional safeguard)
        run: |
          docker logout https://${{ env.GCP_REGION }}-docker.pkg.dev || true

      - name: Ensure Artifact Registry repo exists
        run: |
         if ! gcloud artifacts repositories describe my-repo --location=${{ env.GCP_REGION }} >/dev/null 2>&1; then
         gcloud artifacts repositories create my-repo \
         --repository-format=docker \
         --location=${{ env.GCP_REGION }} \
         --description="Docker repo for my project"
         echo "Waiting for repo to be ready..."
         sleep 15
         fi
    

      - name: Docker login to GCP Artifact Registry
        run: |
          docker logout https://${{ env.GCP_REGION }}-docker.pkg.dev || true
          gcloud auth configure-docker ${{ env.GCP_REGION }}-docker.pkg.dev --quiet

        # âœ… (Optional fallback: Manual login if gcloud helper fails)
      - name: Fallback Docker login (only if needed)
        if: failure()
        run: |
          gcloud auth print-access-token | \
          docker login -u oauth2accesstoken --password-stdin https://${{ env.GCP_REGION }}-docker.pkg.dev

      # Build Docker Image
      - name: Build GCP Image
        run: |
          docker build -t $IMAGE_NAME -f flask_app/Dockerfile .
          docker tag $IMAGE_NAME:latest \
            ${{ env.GCP_REGION }}-docker.pkg.dev/$GCP_PROJECT_ID/my-repo/$IMAGE_NAME:${GITHUB_SHA}

      - name: Login to Artifact Registry
        run: |
          gcloud auth configure-docker ${{ env.GCP_REGION }}-docker.pkg.dev --quiet

      - name: Push to GCP Artifact Registry
        run: |
          docker push \
            ${{ env.GCP_REGION }}-docker.pkg.dev/$GCP_PROJECT_ID/my-repo/$IMAGE_NAME:${GITHUB_SHA}

      - name: Create GCP Artifact Registry Pull Secret
        run: |
          kubectl create secret docker-registry gcp-creds \
          --docker-server=${GCP_REGION}-docker.pkg.dev \
          --docker-username=_json_key \
          --docker-password="$(echo "${{ secrets.GCP_SA_KEY }}" | base64 --decode)" \
          -n default || true

      - name: Update kubeconfig for GKE
        run: |
         echo "Updating kubeconfig for GKE cluster..."
          gcloud container clusters get-credentials $GCP_CLUSTER_NAME \
         --region $GCP_REGION \
         --project $GCP_PROJECT_ID
         echo "Current kubectl context:"
         kubectl config current-context
    

      # Install ArgoCD on GCP
      - name: Install ArgoCD on GKE
        run: |
          kubectl create namespace argocd || true
          kubectl apply -n argocd \
            -f https://raw.githubusercontent.com/argoproj/argo-cd/stable/manifests/install.yaml
          kubectl apply \
            -f https://raw.githubusercontent.com/argoproj/argo-rollouts/stable/manifests/install.yaml
          kubectl wait --for=condition=ready pod -n argocd --selector=app.kubernetes.io/name=argocd-server --timeout=300s

          # Wait additionally until the argocd-cm exists
          until kubectl get configmap argocd-cm -n argocd >/dev/null 2>&1; do
             echo "Waiting for argocd-cm to be created..."
             sleep 5
          done



      - name: Expose ArgoCD server externally
        run: |
          kubectl -n argocd patch svc argocd-server -p '{"spec": {"type": "LoadBalancer"}}'
          # Wait until an external IP/DNS is assigned
           ARGOCD_SERVER_EXTERNAL=""
          while [ -z "$ARGOCD_SERVER_EXTERNAL" ]; do
          echo "Waiting for ArgoCD LoadBalancer IP..."
           ARGOCD_SERVER_EXTERNAL=$(kubectl -n argocd get svc argocd-server -o jsonpath='{.status.loadBalancer.ingress[0].hostname}')
           if [ -z "$ARGOCD_SERVER_EXTERNAL" ]; then
           ARGOCD_SERVER_EXTERNAL=$(kubectl -n argocd get svc argocd-server \
          -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
          fi
           sleep 5
           done
           echo "ArgoCD external endpoint: $ARGOCD_SERVER_EXTERNAL"
          echo "ARGOCD_SERVER_EXTERNAL=$ARGOCD_SERVER_EXTERNAL" >> $GITHUB_ENV

      # Update gitop branch
      - name: Update GCP rollout manifests
        run: |
          git config --global user.name "GitHub Actions"
          git config --global user.email "actions@github.com"

          git clone --branch gitop \
            https://x-access-token:${{ secrets.GITHUB_TOKEN }}@github.com/${{ github.repository }} gitop

          cd gitop/argocd

          # Update GCP Rollout image
          sed -i "s|\${GITHUB_SHA}|$GITHUB_SHA|" flask-app-gcp-rollout.yaml
          sed -i "s|\${GCP_PROJECT_ID}|$GCP_PROJECT_ID|" flask-app-gcp-rollout.yaml

          git add flask-app-gcp-rollout.yaml
          git commit -m "Update GCP rollout image $GITHUB_SHA" || true
          git push origin gitop || true

      - name: Fetch DB credentials from Terraform outputs
        run: |
          # chackout master to fetch latest terraform outputs
          git fetch origin master
          git checkout master
          # GCP DB credentials
          export GCP_DB_USERNAME=$(terraform output -raw gcp_db_username)
          export GCP_DB_PASSWORD=$(terraform output -raw gcp_db_password)
          export GCP_DB_HOST=$(terraform output -raw gcp_db_host)
          export GCP_DB_NAME=$(terraform output -raw gcp_db_name)

          echo "GCP_DB_USERNAME=$GCP_DB_USERNAME" >> $GITHUB_ENV
          echo "GCP_DB_PASSWORD=$GCP_DB_PASSWORD" >> $GITHUB_ENV
          echo "GCP_DB_HOST=$GCP_DB_HOST" >> $GITHUB_ENV
          echo "GCP_DB_NAME=$GCP_DB_NAME" >> $GITHUB_ENV
          echo "BRANCH_NAME=$BRANCH_NAME" >> $GITHUB_ENV


      - name: Apply Kubernetes Secret
        run: |
           cd gitop/argocd/k8s
           envsubst < secret-gcp.yaml | kubectl apply -f -

            
      - name: deploy ingress-gcp and service-gcp
        run: |
          cd gitop/argocd/k8s
          kubectl apply -f ingress-gcp.yaml 
          kubectl apply -f service-gcp.yaml   
      
      

       
          

      - name: Create or Upsert ArgoCD App (GCP)
        run: |
         argocd app create flask-app-gcp \
          --repo  https://github.com/${{ github.repository }} \
          --path argocd \
          --revision gitop \
          --dest-server https://kubernetes.default.svc \
          --dest-namespace default \
          --server https://${{ steps.argocd-endpoint.outputs.external }} \
          --grpc-web=false \
          --upsert \
          --core  

      - name: Sync GCP App
        run: |
         argocd app sync flask-app-gcp
          --grpc-web=false \
          --server https://${{ steps.argocd-endpoint.outputs.external }} \
           

          

      - name: Update ArgoCD App Image
        run: |
         echo "Updating ArgoCD deployment image to $IMAGE_URI ..."
         argocd app set flask-app-gcp \
           --image $IMAGE_URI \
           --grpc-web=false \
           --server https://${{ steps.argocd-endpoint.outputs.external }} \
            
         argocd app sync flask-app-gcp  \
            --grpc-web=false \
            --server https://${{ steps.argocd-endpoint.outputs.external }} \
            


        # ----------------------------------------
      # ðŸš¨ SLACK NOTIFICATION FOR GCP JOB
      # ----------------------------------------
      - name: Slack Notify GCP Job
        if: always()
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
        run: |
          STATUS="${{ job.status }}"
          COMMIT=$GITHUB_SHA
          REPO=$GITHUB_REPOSITORY
          JOB="GCP Build & Deploy"

          curl -X POST -H 'Content-type: application/json' \
            --data "{
              \"text\": \"*$JOB* finished with status: *$STATUS*\nRepo: $REPO\nCommit: $COMMIT\"
            }" \
            $SLACK_WEBHOOK_URL

            

#############################################################################################

# Below steps to use if you do not want to use ArgoCD for deployment
#############################################################################################

##### if step 8 is used, skeep step 9 and vice versa #####
# 8ï¸âƒ£ Deploy to GKE
# - name: Deploy to GKE
#   run: |
#     git fetch origin gitop
#     git checkout gitop
#     kubectl apply -f k8s/flask-app/deployment-gcp.yaml
# kubectl apply -f k8s/service.yaml
# kubectl apply -f k8s/ingress-gcp.yaml
# kubectl apply -f k8s/secret-gcp.yaml

# # Deploy to AWS Eks
# - name: Deploy to AWS EKS
#   env:
#     AWS_REGION: ${{ env.AWS_REGION }}
#     CLUSTER_NAME:  multi-cloud-cluster # replace with your EKS cluster name
#   run: |
#     # Update kubeconfig for EKS
#      git fetch origin gitop
#      git checkout gitop
#      aws eks update-kubeconfig --name $CLUSTER_NAME --region $AWS_REGION
#      kubectl apply -f k8s/flask-app/deployment-aws.yaml
# kubectl apply -f k8s/service.yaml
# kubectl apply -f k8s/ingress-aws.yaml
# kubectl apply -f k8s/secret-aws.yaml

##### end of alternative steps #####

