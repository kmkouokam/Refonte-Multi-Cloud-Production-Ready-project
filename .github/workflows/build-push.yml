name: Build and Push Flask App Image #

on:
  push:
    branches: ["flask-app"]

permissions:
  contents: write
  id-token: write

env:
  IMAGE_NAME: flask-app

jobs:
  # ----------------------------------------
  # 1Ô∏è‚É£ AWS JOB
  # ----------------------------------------
  aws-build-push:
    runs-on: [self-hosted, linux, vpc-runner]
    environment: production

    env:
      AWS_REGION: ${{ secrets.AWS_REGION }}
      AWS_ACCOUNT_ID: ${{ secrets.AWS_ACCOUNT_ID }}
      ARGOCD_ADMIN_PASSWORD: ${{secrets.ARGOCD_ADMIN_PASSWORD}}
      # ARGOCD_SERVER: localhost:8080

       
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Check AWS Identity (Self-Hosted Runner)
        run: aws sts get-caller-identity

      - name: Login to AWS ECR
        run: |
          aws ecr get-login-password --region $AWS_REGION |
          docker login --username AWS --password-stdin \
          $AWS_ACCOUNT_ID.dkr.ecr.$AWS_REGION.amazonaws.com

      # Build Docker Image
      - name: Build Image
        run: |
          docker build -t $IMAGE_NAME -f flask_app/Dockerfile .
          docker tag $IMAGE_NAME:latest \
            $AWS_ACCOUNT_ID.dkr.ecr.$AWS_REGION.amazonaws.com/$IMAGE_NAME:${GITHUB_SHA}

      - name: Push Image to AWS ECR
        run: |
          docker push \
            $AWS_ACCOUNT_ID.dkr.ecr.$AWS_REGION.amazonaws.com/$IMAGE_NAME:${GITHUB_SHA}

      - name: Set IMAGE_URI for AWS
        run: |
          echo "IMAGE_URI=${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/${IMAGE_NAME}:${GITHUB_SHA}" >> $GITHUB_ENV

      # Configure EKS
      - name: Update kubeconfig for AWS EKS
        env:
          AWS_REGION: ${{ env.AWS_REGION }}
          CLUSTER_NAME: multi-cloud-cluster
        run: |
          aws eks update-kubeconfig \
            --name multi-cloud-cluster \
            --region $AWS_REGION \
             --alias eks-prod \

      - name: Create ECR Pull Secret
        run: |
          kubectl create secret docker-registry ecr-creds \
          --docker-server=$AWS_ACCOUNT_ID.dkr.ecr.$AWS_REGION.amazonaws.com \
          --docker-username=AWS \
          --docker-password=$(aws ecr get-login-password --region $AWS_REGION) \
          -n default || true

      - name: Install Helm
        run: |
          curl -fsSL https://raw.githubusercontent.com/helm/helm/master/scripts/get-helm-3 | bash

      # 1Ô∏è‚É£ Detect VPC ID
      - name: Fetch VPC ID
        run: |
          echo "Fetching VPC ID for cluster..."
          VPC_ID=$(aws eks describe-cluster --name multi-cloud-cluster --region $AWS_REGION \
          --query "cluster.resourcesVpcConfig.vpcId" --output text)
          echo "VPC_ID=$VPC_ID" >> $GITHUB_ENV

      # 2Ô∏è‚É£ Install CRDs
      - name: Install AWS Load Balancer Controller CRDs
        run: |
          echo "Installing AWS Load Balancer Controller CRDs..."
           kubectl apply -f https://raw.githubusercontent.com/aws/eks-charts/master/stable/aws-load-balancer-controller/crds/crds.yaml --validate=false

      # 3Ô∏è‚É£ Add Helm repo
      - name: Add Helm repo for AWS charts
        run: |
          helm repo add eks https://aws.github.io/eks-charts
          helm repo update

      #  Install or upgrade AWS Load Balancer Controller
      - name: Install AWS Load Balancer Controller via Helm
        run: |
          echo "Installing AWS Load Balancer Controller..."
          helm upgrade --install aws-load-balancer-controller eks/aws-load-balancer-controller \
           -n kube-system \
           --set clusterName=multi-cloud-cluster \
          --set serviceAccount.create=true \
          --set region=$AWS_REGION \
          --set vpcId=$VPC_ID \
          --set crds.create=false

      #  Wait for controller to be ready
      - name: Wait for AWS Load Balancer Controller to be healthy
        run: |
          kubectl wait --for=condition=available deployment/aws-load-balancer-controller \
          -n kube-system --timeout=300s
  
      # - name: Port-forward ArgoCD server
      #   run: |
      #    kubectl -n argocd port-forward svc/argocd-server 8080:443 &
      #     sleep 10



      - name: Install ArgoCD on AWS
        run: |
          kubectl create namespace argocd || true
          kubectl apply -n argocd \
            -f https://raw.githubusercontent.com/argoproj/argo-cd/stable/manifests/install.yaml --validate=false

            kubectl apply \
            -f https://raw.githubusercontent.com/argoproj/argo-rollouts/stable/manifests/install.yaml
          kubectl wait --for=condition=ready pod -n argocd --selector=app.kubernetes.io/name=argocd-server --timeout=300s

          # Wait additionally until the argocd-cm exists
          until kubectl get configmap argocd-cm -n argocd >/dev/null 2>&1; do
            echo "Waiting for argocd-cm to be created..."
            sleep 5
          done

       
      - name: Fetch DB credentials from terraform outputs
        run: |
          # chackout master to fetch latest terraform outputs
          git fetch origin master
          git checkout master 
          # AWS DB credentials
          export AWS_DB_USERNAME=$(terraform output -raw aws_db_username)
          export AWS_DB_PASSWORD=$(terraform output -raw aws_db_password)
          export AWS_DB_HOST=$(terraform output -raw aws_db_host)
          export AWS_DB_NAME=$(terraform output -raw aws_db_name)

          # Persist to GitHub Actions environment
          echo "AWS_DB_USERNAME=$AWS_DB_USERNAME" >> $GITHUB_ENV
          echo "AWS_DB_PASSWORD=$AWS_DB_PASSWORD" >> $GITHUB_ENV
          echo "AWS_DB_HOST=$AWS_DB_HOST" >> $GITHUB_ENV
          echo "AWS_DB_NAME=$AWS_DB_NAME" >> $GITHUB_ENV

      - name: Apply Kubernetes Secret
        run: |
          git fetch origin gitop
          git checkout gitop
           cd argocd/k8s
           envsubst < secret-aws.yaml | kubectl apply -f -

      - name: deploy ingress-aws and service-aws
        run: |
          git fetch origin gitop
          git checkout gitop
          cd argocd/k8s
          kubectl apply -f ingress-aws.yaml 
          kubectl apply -f service-aws.yaml 
         

      - name: Update kubeconfig AWS
        run: |
          aws eks update-kubeconfig \
            --name multi-cloud-cluster \
            --region $AWS_REGION
        env:
          AWS_REGION: ${{ env.AWS_REGION }}

      - name: Apply Kubernetes Rollout (AWS)
        run: |
          git fetch origin gitop
          git checkout gitop
          cd argocd
          envsubst < flask-app-aws-rollout.yaml | kubectl apply -f -

      # - name: Fetch ArgoCD admin password
      #   run: |
      #    ARGO_PWD=$(kubectl -n argocd get secret argocd-initial-admin-secret \
      #    -o jsonpath="{.data.password}" | base64 -d)
      #     echo "ARGOCD_ADMIN_PASSWORD=$ARGO_PWD" >> $GITHUB_ENV


      # - name: ArgoCD login
      #   run: |
      #     echo "Using ArgoCD server: localhost:8080"
      #     argocd login localhost:8080 \
      #     --username admin \
      #     --password $ARGOCD_ADMIN_PASSWORD \
      #     --insecure

      - name: Create or Upsert ArgoCD App (AWS)
        run: |
          argocd app create flask-app-aws \
           echo "Using ArgoCD server: localhost:8080"
           --repo https://github.com/kmkouokam/Refonte-Multi-Cloud-Production-Ready-project.git  \
           --path argocd \
           --revision gitop \
           --dest-server https://kubernetes.default.svc \
           --dest-namespace default \
           --upsert \
           --server localhost:8080 \
           --grpc-web=false \
           --insecure \
           --directory-recurse

      - name: Update ArgoCD App Image (AWS)
        run: |
          echo "Using ArgoCD server: localhost:8080"
          echo "Updating ArgoCD deployment image to $IMAGE_URI ..."
          argocd app set flask-app-aws \
          --image $IMAGE_URI \
          --grpc-web=false \
          --server localhost:8080 \
          --timeout 60

          argocd app sync flask-app-aws \
            --grpc-web=false \
            --timeout 60 \
            --server localhost:8080

        # ----------------------------------------
      #
      # üö® SLACK NOTIFICATION FOR AWS JOB
      # ----------------------------------------
      - name: Slack Notify AWS Job
        if: always()
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
        run: |
          STATUS="${{ job.status }}"
          COMMIT=$GITHUB_SHA
          REPO=$GITHUB_REPOSITORY
          JOB="AWS Build & Deploy"

          curl -X POST -H 'Content-type: application/json' \
            --data "{
              \"text\": \"*$JOB* finished with status: *$STATUS*\nRepo: $REPO\nCommit: $COMMIT\"
            }" \
            $SLACK_WEBHOOK_URL

  # ----------------------------------------
  # 2Ô∏è‚É£ GCP JOB
  # ----------------------------------------
  gcp-build-push:
    runs-on: [self-hosted, linux, vpc-runner]
    # needs: aws-build-push   # wait for AWS job to finish before starting GCP job

    env:
      GCP_PROJECT_ID: ${{ secrets.GCP_PROJECT_ID }}
      GCP_PROJECT_NUMBER: ${{ secrets.GCP_PROJECT_NUMBER }}
      GCP_CREDENTIALS_JSON: ${{ secrets.GCP_CREDENTIALS_JSON }}
      IMAGE_NAME: flask-app
      GCP_REGION: us-east4
      GCP_REPO: my-repo
      GCP_CLUSTER_NAME:  my-gcp-cluster-656a2a339247
      PUBLIC_IP: ${{secrets.PUBLIC_IP}}
      # ARGOCD_SERVER: localhost:8080
       

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      # Authenticate to GCP
      - name: Authenticate to GCP
        uses: google-github-actions/auth@v3
        with:
          credentials_json: ${{ env.GCP_CREDENTIALS_JSON }}
          project_id: ${{ env.GCP_PROJECT_ID }}
          # workload_identity_provider: ${{ secrets.WORKLOAD_IDENTITY_PROVIDER }}
          # service_account: "refonte-project@prod-251618-359501.iam.gserviceaccount.com"

      - name: Fix gcloud install location
        run: |
          echo "CLOUDSDK_ROOT_DIR=$HOME/google-cloud-sdk" >> $GITHUB_ENV
           echo "PATH=$HOME/google-cloud-sdk/bin:$PATH" >> $GITHUB_ENV

        # 3Ô∏è‚É£ Install gcloud CLI and kubectl
      - name: Setup gcloud CLI
        uses: google-github-actions/setup-gcloud@v3
        with:
          project_id: ${{ env.GCP_PROJECT_ID }}
          install_components: "kubectl"

      # - name: Setup gcloud cloud SDK
      #   uses: google-github-actions/setup-gcloud@v3
      #   with:
      #     project_id: ${{ env.GCP_PROJECT_ID }}
      #     service_account_key: ${{ secrets.GCP_SA_KEY }}
      #     export_default_credentials: true
      - name: Get GKE credentials
        run: |
          gcloud container clusters get-credentials ${{ env.GCP_CLUSTER_NAME }} \
          --region ${{ env.GCP_REGION }} \
          --project ${{ env.GCP_PROJECT_ID }}

        # 4Ô∏è‚É£ Optional: Check kubectl context
      - name: Check kubectl context
        run: kubectl config current-context

      - name: Install Google Cloud SDK
        run: |
          # Create safe directory
          mkdir -p /home/ec2-user/gcloud
          cd /home/ec2-user/gcloud 
          # Detect package manager
          if command -v apt-get >/dev/null 2>&1; then
           sudo apt-get update -y
           sudo apt-get install -y apt-transport-https ca-certificates gnupg curl
          elif command -v yum >/dev/null 2>&1 || command -v dnf >/dev/null 2>&1; then
           sudo yum update -y || sudo dnf update -y
           sudo yum install -y curl ca-certificates || sudo dnf install -y curl ca-certificates
          else
            echo "No supported package manager found"
           exit 1
          fi

           # If using apt-get, install Google Cloud SDK via apt repo
          if command -v apt-get >/dev/null 2>&1; then
            curl -fsSL https://packages.cloud.google.com/apt/doc/apt-key.gpg | sudo gpg --dearmor -o /usr/share/keyrings/cloud.google.gpg
            echo "deb [signed-by=/usr/share/keyrings/cloud.google.gpg] https://packages.cloud.google.com/apt cloud-sdk main" | \
            sudo tee /etc/apt/sources.list.d/google-cloud-sdk.list
            sudo apt-get update
            sudo apt-get install -y google-cloud-sdk
          else
          # For Amazon Linux 2023 or other yum/dnf distros, use Google's install script
            sudo -u ec2-user bash
            cd ~
            curl -O https://dl.google.com/dl/cloudsdk/channels/rapid/downloads/google-cloud-cli-linux-x86_64.tar.gz
            tar -xf google-cloud-cli-linux-x86_64.tar.gz
             ./google-cloud-sdk/install.sh --quiet
            echo 'source $HOME/google-cloud-sdk/path.bash.inc' >> ~/.bashrc
            echo 'source $HOME/google-cloud-sdk/completion.bash.inc' >> ~/.bashrc
            source ~/.bashrc
           fi

      - name: Install GKE auth plugin and authenticate to GCP
        run: |
          # Install gke plugin
           gcloud components install gke-gcloud-auth-plugin --quiet

           # Authenticate to GCP
            echo "${{ secrets.GCP_SA_KEY }}" | base64 --decode > gcp-key.json
            gcloud auth activate-service-account --key-file=gcp-key.json --quiet
            # Verify
            gcloud version
            kubectl version --client

        #  Clean and reconfigure Docker auth for Artifact Registry
      - name: Clean old Docker logins (optional safeguard)
        run: |
          docker logout https://${{ env.GCP_REGION }}-docker.pkg.dev || true

      - name: Ensure Artifact Registry repo exists
        run: |
          if ! gcloud artifacts repositories describe my-repo --location=${{ env.GCP_REGION }} >/dev/null 2>&1; then
          gcloud artifacts repositories create my-repo \
          --repository-format=docker \
          --location=${{ env.GCP_REGION }} \
          --description="Docker repo for my project"
          echo "Waiting for repo to be ready..."
          sleep 15
          fi

      - name: Docker login to GCP Artifact Registry
        run: |
          docker logout https://${{ env.GCP_REGION }}-docker.pkg.dev || true
          gcloud auth configure-docker ${{ env.GCP_REGION }}-docker.pkg.dev --quiet

        # ‚úÖ (Optional fallback: Manual login if gcloud helper fails)
      - name: Fallback Docker login (only if needed)
        if: failure()
        run: |
          gcloud auth print-access-token | \
          docker login -u oauth2accesstoken --password-stdin https://${{ env.GCP_REGION }}-docker.pkg.dev

      # Build Docker Image
      - name: Build GCP Image
        run: |
          docker build -t $IMAGE_NAME -f flask_app/Dockerfile .
          docker tag $IMAGE_NAME:latest \
            ${{ env.GCP_REGION }}-docker.pkg.dev/$GCP_PROJECT_ID/my-repo/$IMAGE_NAME:${GITHUB_SHA}

      - name: Login to Artifact Registry
        run: |
          gcloud auth configure-docker ${{ env.GCP_REGION }}-docker.pkg.dev --quiet

      - name: Push to GCP Artifact Registry
        run: |
          docker push \
            ${{ env.GCP_REGION }}-docker.pkg.dev/$GCP_PROJECT_ID/my-repo/$IMAGE_NAME:${GITHUB_SHA}

      - name: Set IMAGE_URI for GCP
        run: |
          echo "IMAGE_URI=${GCP_REGION}-docker.pkg.dev/${GCP_PROJECT_ID}/my-repo/${IMAGE_NAME}:${GITHUB_SHA}" >> $GITHUB_ENV

      - name: Update Cluster
        run: |
          gcloud container clusters update "$GCP_CLUSTER_NAME" \
          --region us-east4 \
          --enable-master-authorized-networks \
          --master-authorized-networks 0.0.0.0/0 \
          --project prod-251618-359501
           echo "Current kubectl context:"
          kubectl config current-context

      - name: Create GCP Artifact Registry Pull Secret
        run: |
          # Full registry URL
           REGISTRY_URL="${GCP_REGION}-docker.pkg.dev/${GCP_PROJECT}/${GCP_REPO}"
          kubectl create secret docker-registry gcp-creds \
          --docker-server="${REGISTRY_URL}" \
          --namespace default \
          --docker-username=_json_key \
          --docker-password="$(echo "${{ secrets.GCP_SA_KEY }}" | base64 --decode)" \
          --dry-run=client -o yaml | kubectl apply -f -

      - name: Update kubeconfig for GKE
        run: |
          echo "Updating kubeconfig for GKE cluster..."
           gcloud container clusters get-credentials "$GCP_CLUSTER_NAME" \
          --region "$GCP_REGION" \
          --project "$GCP_PROJECT_ID" \

      - name: Test GKE access
        run: |
          kubectl get nodes

      # - name: Connect to ArgoCD via port-forward
      #   run: |
      #    kubectl -n argocd port-forward svc/argocd-server 8080:443 &
      #    sleep 10


      # Install ArgoCD on GCP
      - name: Install ArgoCD on GKE
        run: |
          kubectl create namespace argocd || true
          kubectl apply -n argocd \
            -f https://raw.githubusercontent.com/argoproj/argo-cd/stable/manifests/install.yaml
          kubectl apply \
            -f https://raw.githubusercontent.com/argoproj/argo-rollouts/stable/manifests/install.yaml
          kubectl wait --for=condition=ready pod -n argocd --selector=app.kubernetes.io/name=argocd-server --timeout=300s

          # Wait additionally until the argocd-cm exists
          until kubectl get configmap argocd-cm -n argocd >/dev/null 2>&1; do
             echo "Waiting for argocd-cm to be created..."
             sleep 5
          done

      

       

      - name: Fetch DB credentials from Terraform outputs
        run: |
          # chackout master to fetch latest terraform outputs
          git fetch origin master
          git checkout master
          # GCP DB credentials
          export GCP_DB_USERNAME=$(terraform output -raw gcp_db_username)
          export GCP_DB_PASSWORD=$(terraform output -raw gcp_db_password)
          export GCP_DB_HOST=$(terraform output -raw gcp_db_host)
          export GCP_DB_NAME=$(terraform output -raw gcp_db_name)

          echo "GCP_DB_USERNAME=$GCP_DB_USERNAME" >> $GITHUB_ENV
          echo "GCP_DB_PASSWORD=$GCP_DB_PASSWORD" >> $GITHUB_ENV
          echo "GCP_DB_HOST=$GCP_DB_HOST" >> $GITHUB_ENV
          echo "GCP_DB_NAME=$GCP_DB_NAME" >> $GITHUB_ENV
          echo "BRANCH_NAME=$BRANCH_NAME" >> $GITHUB_ENV

      - name: Apply Kubernetes Secret
        run: |
          git fetch origin gitop
          git checkout gitop  
          cd argocd/k8s
          envsubst < secret-gcp.yaml | kubectl apply -f -

      - name: deploy ingress-gcp and service-gcp
        run: |
          git fetch origin gitop
          git checkout gitop
          cd argocd/k8s
          kubectl apply -f ingress-gcp.yaml 
          kubectl apply -f service-gcp.yaml 
          

      - name: Update kubeconfig GCP
        run: |
          echo "Cluster: $GCP_CLUSTER_NAME, Region: $GCP_REGION, Project: $GCP_PROJECT_ID"
           gcloud container clusters get-credentials "$GCP_CLUSTER_NAME" \
             --region "$GCP_REGION" \
             --project "$GCP_PROJECT_ID"

      - name: Apply Kubernetes Rollout (GCP)
        run: |
          git fetch origin gitop
          git checkout gitop
          cd argocd
          envsubst < flask-app-gcp-rollout.yaml | kubectl apply -f -

       
      # - name: Fetch ArgoCD admin password
      #   run: |
      #    ARGO_PWD=$(kubectl -n argocd get secret argocd-initial-admin-secret \
      #    -o jsonpath="{.data.password}" | base64 -d)
      #     echo "ARGOCD_ADMIN_PASSWORD=$ARGO_PWD" >> $GITHUB_ENV


      # - name: ArgoCD login
      #   run: |
      #     echo "Using ArgoCD server: localhost:8080"
      #     argocd login localhost:8080 \
      #     --username admin \
      #     --password $ARGOCD_ADMIN_PASSWORD \
      #     --insecure

      - name: Create or Upsert ArgoCD App (GCP)
        run: |
          echo "Using ArgoCD server: localhost:8080"
          argocd app create flask-app-gcp \
           --repo  https://github.com/${{ github.repository }} \
           --path argocd \
           --revision gitop \
           --dest-server https://kubernetes.default.svc \
           --dest-namespace default \
           --server localhost:8080 \
           --grpc-web=false \
           --upsert \
           --insecure \
           --directory-recurse

      - name: Update ArgoCD App Image & Sync (GCP)
        run: |
          echo "Using ArgoCD server: localhost:8080"
          echo "Updating ArgoCD deployment image to $IMAGE_URI ..."
          argocd app set flask-app-gcp \
            --image "$IMAGE_URI" \
            --grpc-web=false \
            --server localhost:8080 \
             
          argocd app sync flask-app-gcp  \
             --grpc-web=false \
             --server localhost:8080 \
      #

      # ----------------------------------------
      # üö® SLACK NOTIFICATION FOR GCP JOB
      # ----------------------------------------
      - name: Slack Notify GCP Job
        if: always()
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
        run: |
          STATUS="${{ job.status }}"
          COMMIT=$GITHUB_SHA
          REPO=$GITHUB_REPOSITORY
          JOB="GCP Build & Deploy"

          curl -X POST -H 'Content-type: application/json' \
            --data "{
              \"text\": \"*$JOB* finished with status: *$STATUS*\nRepo: $REPO\nCommit: $COMMIT\"
            }" \
            $SLACK_WEBHOOK_URL

#############################################################################################

# Below steps to use if you do not want to use ArgoCD for deployment
#############################################################################################

##### if step 8 is used, skeep step 9 and vice versa #####
# 8Ô∏è‚É£ Deploy to GKE
# - name: Deploy to GKE
#   run: |
#     git fetch origin gitop
#     git checkout gitop
#     kubectl apply -f k8s/flask-app/deployment-gcp.yaml
# kubectl apply -f k8s/service.yaml
# kubectl apply -f k8s/ingress-gcp.yaml
# kubectl apply -f k8s/secret-gcp.yaml

# # Deploy to AWS Eks
# - name: Deploy to AWS EKS
#   env:
#     AWS_REGION: ${{ env.AWS_REGION }}
#     CLUSTER_NAME:  multi-cloud-cluster # replace with your EKS cluster name
#   run: |
#     # Update kubeconfig for EKS
#      git fetch origin gitop
#      git checkout gitop
#      aws eks update-kubeconfig --name $CLUSTER_NAME --region $AWS_REGION
#      kubectl apply -f k8s/flask-app/deployment-aws.yaml
# kubectl apply -f k8s/service.yaml
# kubectl apply -f k8s/ingress-aws.yaml
# kubectl apply -f k8s/secret-aws.yaml

##### end of alternative steps #####
